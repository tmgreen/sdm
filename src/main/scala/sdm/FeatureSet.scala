package sdm

import collection._
import scala.collection.mutable.ArrayBuffer
import scala.util.Sorting
import scala.collection.immutable.BitSet

/** Immutable, max size < 32
  */
class FeatureSet private(
    val ncells: Int,
    val maskSet: BitSet,
    rowMasks: Array[Int]) extends IndexedSeq[Feature] with MatrixLike[Int] {

  /** This is lazy because it is only used when printing the feature set, which
    * may not happen at all for most instances.
    */
  lazy val sorted: IndexedSeq[Int] = maskSet.toIndexedSeq

  override def nrows = ncells

  override def ncols = maskSet.size

  override def cell(row: Int, col: Int): Int = Feature(ncells, sorted(col)).cell(row)

  override def apply(col: Int) = Feature(ncells, sorted(col))

  override def length = ncols

  def contains(f: Feature) = containsMask(f.mask)

  def containsMask(m: Int) = maskSet.contains(m)

  def subsets = maskSet.subsets map { bs => FeatureSet(ncells, bs) }

  def allParadigms: Set[Long] =
    (subsets filter { _.isComplete } map { _.finestParadigm.mask }).toSet

  /** return false if feature set contains any rows of all 0's.  non-complete feature sets
    * are simply ill-formed for the purposes of this analysis, and represent a featureset for
    * a lesser number of cells
    */
  def isComplete = {
    val union = maskSet.foldLeft(0)(_ | _)
    union == FeatureInventory.maxMask(ncells)
  }

  /** @return the finest paradigm generated by this feature set
    * (i.e. what the paradigm will look like if there is no syncretism)
    * NOTE: if there are any "zero" rows in the feature set, the resulting
    * paradigm will also contain a "0" in the corresponding cell.
    */
  def finestParadigm: Paradigm = {
    val maxRow = (1 << ncells) - 1
    var curMax = 0
    val seen = mutable.Map.empty[Int, Int]
    var par = Paradigm(0L)
    var r = 0
    rowMasks foreach { rm =>
      val slotVal = if (rm == 0) {
        0
      } else if (seen.contains(rm)) {
        seen(rm)
      } else {
        curMax += 1
        seen(rm) = curMax
        curMax
      }
      par = par updated (r, slotVal)
      r += 1
    }
    par
  }

  /** return true iff this FeatureSet can generate the complete (finest possible) paradigm.
    * No F* need be calculated for this: just need to verify that all rows are distinct and
    * non-zero.
    */
  def isFine: Boolean = {
    val seen = mutable.BitSet.empty
    rowMasks foreach { rm =>
      if (rm == 0) {
        return false
      } else if (seen.contains(rm)) {
        return false
      } else {
        seen += rm
      }
    }
    true
  }

  /** Create a new set including an added feature as efficiently as possible.
    */
  def +(newFeature: Feature) = {
    val newMask = newFeature.mask
    if (maskSet contains newMask)
      this
    else
      new FeatureSet(ncells, maskSet + newMask, FeatureSet.addFeatureToRowMasksCopy(ncols, rowMasks, newMask))
  }

  /** Compute the And-Complete set for this FeatureSet
    */
  def andComplete: FeatureSet = internalAndComplete(maskSet, maskSet)

  /** if this FeatureSet *is* already And-Complete, then add new feature and compute And-Complete at same time
    */
  def addAndComplete(newFeature: Feature) = {
    val newMask = newFeature.mask
    if (maskSet contains newMask)
      this
    else
      internalAndComplete(maskSet + newMask, BitSet(newMask))
  }

  private[this] def internalAndComplete(bs1: BitSet, bs2: BitSet): FeatureSet = {
    var fstar = bs1
    var active = bs2
    while (active.nonEmpty) {
      val ands = for {
        a <- active
        b <- fstar
        if a != b
        c = a & b
        if c != 0
        if !fstar.contains(c)
      } yield c
      active = ands
      fstar ++= ands
    }
    FeatureSet(ncells, fstar)
  }

}

object FeatureSet {

  def apply(features: Feature*): FeatureSet =
    apply(computeNCells(features: _*), computeMaskSet(features: _*))

  def apply(ncells: Int, features: Seq[Feature]): FeatureSet =
    apply(computeNCells(features: _*), computeMaskSet(features: _*))

  def apply(ncells: Int, maskSet: BitSet): FeatureSet =
    new FeatureSet(ncells, maskSet, computeRowMasks(ncells, maskSet))

  def computeMaskSet(features: Feature*): BitSet =
    (features map (_.mask))(breakOut)

  def computeNCells(features: Feature*): Int = {
    var min = Int.MaxValue
    var max = 0
    features foreach { f =>
      val l = f.length
      if (l < min)
        min = l
      if (l > max)
        max = l
    }
    require(max == 0 || min == max, "All Features in FeatureSet must have same length")
    max
  }
    
  /** if features are layed out as columns (in order defined by FeatureSet),
    * then this function returns the resulting *rows* in this matrix
    */
  private def computeRowMasks(ncells: Int, feats: BitSet): Array[Int] = {
    val rows = Array.ofDim[Int](ncells)
    val last = ncells - 1
    var colShift = feats.size - 1
    // WARNING: this relies on BitSet being a SortedSet
    feats foreach { feat =>
      (0 to last) foreach { r =>
        rows(last - r) |= ((feat >>> r) & 1) << colShift
      }
      colShift -= 1
    }
    rows
  }

  /** nth is the degree of left shift required when or'ing in the new values.
    * It equals the number of features represented already in the
    * supplied rowMask.
    */
  private def addFeatureToRowMasksCopy(nth: Int, rowMasks: Array[Int], newMask: Int): Array[Int] = {
    val newRows = rowMasks.clone
    val last = newRows.length - 1
    (0 to last) foreach { r =>
      newRows(last - r) |= ((newMask >>> r) & 1) << nth
    }
    newRows
  }

}