package sdm

import collection._
import scala.collection.mutable.ArrayBuffer
import scala.util.Sorting
import scala.collection.immutable.BitSet

/** Immutable, max size < 32
  *
  * A set of n-cell Features.  Each feature is identified by its n-bit non-zero
  * integer `mask` field.
  *
  * The maximal FeatureSet contains the same set of Features as the corresponding
  * FeatureInventory of the same number of cells.
  *
  * If thought of as a matrix, with each Feature arranged vertically as a column,
  * then each row of this matrix encodes a paradigm cell.  If two rows have all the
  * same column values then the resulting paradigm contains the same morpheme in the
  * two corresponding cells.  If any row consists of all 0s then the FeatureSet
  * is not "complete", and fails to actually represent an n-celled paradigm at all.
  */
class FeatureSet private[FeatureSet] (val maskSet: BitSet, rowMasks: Array[Int])(implicit val theory: Theory)
    extends IndexedSeq[Feature] with MatrixLike[Int] {

  import theory._

  /** This is lazy because it is only used when printing the feature set, which
    * may not happen at all for most instances.
    */
  lazy val sorted: IndexedSeq[Int] = maskSet.toIndexedSeq

  override def nrows = ncells

  override def ncols = maskSet.size

  override def cell(row: Int, col: Int): Int = Feature(sorted(col)).nthHighestBit(row, ncells)

  override def apply(col: Int) = Feature(sorted(col))

  override def length = ncols

  def contains(f: Feature) = containsMask(f.mask)

  def containsMask(m: Int) = maskSet.contains(m)

  /** an iterator over all subsets of this FeatureSet */
  def subsets = maskSet.subsets map { bs => FeatureSet(bs) }

  def allParadigms: Set[Long] =
    (subsets filter { _.isComplete } map { _.finestParadigm.mask }).toSet

  /** return false if feature set contains any rows of all 0's.  non-complete feature sets
    * are simply ill-formed for the purposes of this analysis, and represent a featureset for
    * a lesser number of cells
    */
  def isComplete = {
    val union = maskSet.foldLeft(0)(_ | _)
    union == maxFeatureMask
  }

  /** @return the finest paradigm generated by this feature set
    * (i.e. what the paradigm will look like if there is no syncretism)
    * NOTE: if there are any "zero" rows in the feature set, the resulting
    * paradigm will also contain a "0" in the corresponding cell.
    */
  def finestParadigm: Paradigm = {
    val maxRow = (1 << ncells) - 1
    var curMax = 0
    val seen = mutable.Map.empty[Int, Int]
    var par = Paradigm(0L)
    var r = 0
    rowMasks foreach { rm =>
      val slotVal = if (rm == 0) {
        0
      } else if (seen.contains(rm)) {
        seen(rm)
      } else {
        curMax += 1
        seen(rm) = curMax
        curMax
      }
      par = par updated (r, slotVal)
      r += 1
    }
    par
  }

  /** return true iff this FeatureSet can generate the complete (finest possible) paradigm.
    * No F* need be calculated for this: just need to verify that all rows are distinct and
    * non-zero.
    * 
    * NOTE: isFine implies isComplete, so there's no need to check both 
    */
  def isFine: Boolean = {
    val seen = mutable.BitSet.empty
    rowMasks foreach { rm =>
      if (rm == 0) {
        return false
      } else if (seen.contains(rm)) {
        return false
      } else {
        seen += rm
      }
    }
    true
  }

  /** Create a new set including an added feature as efficiently as possible.
    */
  def +(newFeature: Feature) = {
    val newMask = newFeature.mask
    if (maskSet contains newMask)
      this
    else
      new FeatureSet(maskSet + newMask, FeatureSet.addFeatureToRowMasksCopy(ncols, rowMasks, newMask))
  }

  /** Compute the And-Complete set for this FeatureSet
    */
  def andComplete: FeatureSet = internalAndComplete(maskSet, maskSet)

  /** if this FeatureSet *is* already And-Complete, then add new feature and compute And-Complete at same time
    */
  def addAndComplete(newFeature: Feature) = {
    val newMask = newFeature.mask
    if (maskSet contains newMask)
      this
    else
      internalAndComplete(maskSet + newMask, BitSet(newMask))
  }

  private[this] def internalAndComplete(bs1: BitSet, bs2: BitSet): FeatureSet = {
    var fstar = bs1
    var active = bs2
    while (active.nonEmpty) {
      val ands = for {
        a <- active
        b <- fstar
        if a != b
        c = a & b
        if c != 0
        if !fstar.contains(c)
      } yield c
      active = ands
      fstar ++= ands
    }
    FeatureSet(fstar)
  }

}

object FeatureSet {

  def apply(features: Feature*)(implicit theory: Theory): FeatureSet =
    apply(computeMaskSet(features: _*))

  def apply(implicit theory: Theory): FeatureSet = {
    new FeatureSet(BitSet.empty, Array[Int]())
  }

  def apply(maskSet: BitSet)(implicit theory: Theory): FeatureSet =
    new FeatureSet(maskSet, computeRowMasks(theory.ncells, maskSet))

  def computeMaskSet(features: Feature*): BitSet =
    (features map (_.mask))(breakOut)

  /** if features are layed out as columns (in order defined by FeatureSet),
    * then this function returns the resulting *rows* in this matrix
    */
  private def computeRowMasks(ncells: Int, feats: BitSet): Array[Int] = {
    val rows = Array.ofDim[Int](ncells)
    val last = ncells - 1
    var colShift = feats.size - 1
    // WARNING: this relies on BitSet being a SortedSet
    feats foreach { feat =>
      (0 to last) foreach { r =>
        rows(last - r) |= ((feat >>> r) & 1) << colShift
      }
      colShift -= 1
    }
    rows
  }

  /** nth is the degree of left shift required when or'ing in the new values.
    * It equals the number of features represented already in the
    * supplied rowMask.
    */
  private def addFeatureToRowMasksCopy(nth: Int, rowMasks: Array[Int], newMask: Int): Array[Int] = {
    val newRows = rowMasks.clone
    val last = newRows.length - 1
    (0 to last) foreach { r =>
      newRows(last - r) |= ((newMask >>> r) & 1) << nth
    }
    newRows
  }

}