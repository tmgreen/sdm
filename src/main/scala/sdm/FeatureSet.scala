package sdm

import collection._
import scala.collection.mutable.ArrayBuffer
import scala.util.Sorting
import scala.collection.immutable.BitSet

/**
 * Immutable, max size < 32
 */
class FeatureSet(
  val inventory: FeatureInventory,
  val maskSet: BitSet,
  val rowMasks: Array[Int]) extends IndexedSeq[Feature] with MatrixLike[Int] {

  def this(inv: FeatureInventory, maskSet: BitSet) = this(inv, maskSet, FeatureSet.computeRowMasks(inv.ncells, maskSet))

  def this(inv: FeatureInventory, masks: Int*) = this(inv, BitSet(masks: _*))

  /**
   * This is lazy because it is only used when printing the feature set, which
   * may not happen at all for most instances.
   */
  lazy val sorted = {
    val fs = (maskSet map (inventory.mask2feature(_))).toArray
    Sorting.quickSort(fs)
    fs
  }

  /**
   * @return the finest paradigm generated by this feature set
   * (i.e. what the paradigm will look like if there is no syncretism)
   * NOTE: if there are any "zero" rows in the feature set, the resulting
   * paradigm will also contain a "0" in the corresponding cell.
   */
  @deprecated("This code is not used but the alg. will probably get cannibalized so not deleted yet.", "0.1.0")
  def finestParadigm: Array[Byte] = {
    val maxRow = (1 << inventory.ncells) - 1
    var curMax = 0
    val seen = mutable.Map.empty[Int, Int]
    val par = Array.ofDim[Byte](inventory.ncells)
    var r = 0
    rowMasks foreach { rm =>
      val slotVal = if (rm == 0) {
        0
      } else if (seen.contains(rm)) {
        seen(rm)
      } else {
        curMax += 1
        seen(rm) = curMax
        curMax
      }
      par(r) = slotVal.asInstanceOf[Byte]
      r += 1
    }
    par
  }

  override def nrows = inventory.nrows

  override def ncols = maskSet.size

  override def cell(row: Int, col: Int): Int = sorted(col)(row)

  override def apply(col: Int) = sorted(col)

  override def length = ncols

  def contains(f: Feature) = containsMask(f.mask)

  def containsMask(m: Int) = maskSet.contains(m)

  /**
   * return false if feature set contains any rows of all 0's.  non-comprehensive feature sets 
   * are simply ill-formed for the purposes of this analysis, and represent a featureset for
   * a lesser number of cells
   */
  def isComprehensive = {
    val union = maskSet.foldLeft(0)(_ | _)
    union == inventory.maxMask
  }

  /**
   * return true iff this FeatureSet can generate the complete (finest possible) paradigm.
   * No F* need be calculated for this: just need to verify that all rows are distinct and
   * non-zero.
   */
  def isFine: Boolean = {
    val seen = mutable.BitSet.empty
    rowMasks foreach { rm =>
      if (rm == 0) {
        return false
      } else if (seen.contains(rm)) {
        return false
      } else {
        seen += rm
      }
    }
    true
  }

  /**
   * Create a new set including an added feature as efficiently as possible.
   */
  def +(newFeature: Feature) = {
    val newMask = newFeature.mask
    if (maskSet contains newMask)
      this
    else
      new FeatureSet(inventory, maskSet + newMask, FeatureSet.addFeatureToRowMasksCopy(ncols, rowMasks, newMask))
  }

  /**
   * Compute the And-Complete set for this FeatureSet
   */
  def andComplete: FeatureSet = internalAndComplete(maskSet, maskSet)

  /**
   * if this FeatureSet *is* already And-Complete, then add new feature and compute And-Complete at same time
   */
  def addAndComplete(newFeature: Feature) = {
    val newMask = newFeature.mask
    if (maskSet contains newMask)
      this
    else
      internalAndComplete(maskSet + newMask, BitSet(newMask))
  }

  private[this] def internalAndComplete(bs1: BitSet, bs2: BitSet): FeatureSet = {
    var fstar = bs1
    var active = bs2
    while (active.nonEmpty) {
      val ands = for {
        a <- active
        b <- fstar
        if a != b
        c = a & b
        if c != 0
        if !fstar.contains(c)
      } yield c
      active = ands
      fstar ++= ands
    }
    new FeatureSet(inventory, fstar)
  }

}

object FeatureSet {

  /**
   * if features are layed out as columns (in order defined by FeatureSet),
   * then this function returns the resulting *rows* in this matrix
   */
  def computeRowMasks(ncells: Int, feats: BitSet): Array[Int] = {
    val nfeats = feats.size
    val rows = Array.ofDim[Int](ncells)
    var i = 0
    feats foreach { feat =>
      (0 until ncells) foreach { r =>
        rows(r) |= ((feat >>> r) & 1) << i
      }
      i += 1
    }
    rows
  }

  /**
   * nth is the degree of left shift required when or'ing in the new values.
   * It equals the number of features represented already in the
   * supplied rowMask.
   */
  def addFeatureToRowMasksCopy(nth: Int, rowMasks: Array[Int], newMask: Int): Array[Int] = {
    val newRows = rowMasks.clone
    (0 until newRows.length) foreach { r =>
      newRows(r) |= ((newMask >>> r) & 1) << nth
    }
    newRows
  }

}